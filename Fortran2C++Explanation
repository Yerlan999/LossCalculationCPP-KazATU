*************** Общие сведения о конфигурации программы на С++ ********************

1) Открывыет только .xlsx формат с назанием в латинице.
    Пример: "Promzona.xlsx". Необходимо будет переформатировать
    (сохранить как версия 2007-2019) и переименовать.
2) Необходимо переименовать (назвать) листы в файле
    с ["3.1. Фаза А", "3.1. Фаза А (продолжение)", и.т.д.]
    на ["Sheet1", "Sheet2", "Sheet3", "Sheet4", "Sheet5", "Sheet6"]
    соответственно.
3) Раместить Excel документ рядом с программой.


*** Структура Excel файлов с данными о Напряжении и Токе ***

Один файл содержит:
1) 6 листов.
2) Первые два листа содержат данные о Напряжении и Токе первой Фазы соответственно.
   Далее по аналогии. Итого 3 Фазы.
2) Нечетные листы содержат 98 столбцов. Амплитуда и Фаза по Напряжению на каждую гармонику.
   [UM, FUM]. Итого 49 Гармоник.
3) Четные листы содержат 106 столбцов. 98 столбцов из них это Амплитуда и Фаза по Току на каждую гармонику.
   [AIM, FIM]. Остальные 8 столбцов = [knsu, knsi, rmsu, rmsi, funu, funi, fu, fi] соответсвенно.
4) Количество строк у каждой подстанции разное. Примерно ~500. Это количество измерении прибором.


* "Help" > "Search" > "Query" - для справок по синтаксису в среде разработки


**************************** ПреКод ****************************

Юнит 1 - "1. Длина и период"
    Содержание:
        длина линии (км), количество проводов, количество тросов, интервал измерении (мин), количество заземлении троса

Юнит 2 - "2.4 Вводимые общие данные"
    Содержание:
        Х координаты проводов и троссов
        У координаты проводов и троссов
        Удельные проводимости проводов и троссов
        Магнитные проницаемости проводов и троссов
        Поперечные сечения проводов и троссов
        Заземления троса ?

Юнит 4 - "1. Подстанция и ее присоединения"
    Содержание:
        Название подстанции
        Название присоединения(ии)
        Количество замеров для каждого присоединения

Юнит 5 - Введенные общие данные
    Содержание:
        Дублирование содержания Юнита 2

Юнит 6 - Введенные параметры режима
   Содержание:
        Объединение Юнитов 101, 111, 102, 122, 103, 133

Юнит 8 - Результаты расчета
Юнит 10 - EPURAU
Юнит 11 - EPURAI
Юнит 12 - R11
Юнит 30 - PPP
Юнит 31 - PPP1
Юнит 32 - PPP2
Юнит 33 - PPP3
Юнит 34 - PPP4
Юнит 35 - PPP5
Юнит 36 - PPP6
Юнит 37 - PPP7
Юнит 38 - PPP8

Юнит 101 - 3.1. Фаза А
Юнит 111 - 3.1. Фаза А (продолжение)
Юнит 102 - 3.2. Фаза В
Юнит 122 - 3.2. Фаза В (продолжение)
Юнит 103 - 3.3. Фаза С
Юнит 133 - 3.3. Фаза С (продолжение)


**************************** Форматы ****************************

    Дескрипторы:
        I - целочисленное
        A - символ
        F - цисло с плавующей точкой
        E - экспоненциальное число
        Х - пропуск (пробел)

    r[Дескриптор]w
    где:
        r - повторение чтения
        w - ширина чтения


    2   FORMAT(6F20.15)
    2   FORMAT(6F20.15)
    3   FORMAT(80X)
    3   FORMAT(80X)
    6   FORMAT(20F15.10)
    6   FORMAT(20F15.10)
    7   FORMAT(8I6)
    7   FORMAT(8I6)
    8   FORMAT(24F20.15)
    8   FORMAT(24F20.15)
    9   FORMAT(20x,24F20.15)
    9   FORMAT(20x,24F20.15)

   70   FORMAT(I4,2I10,F12.1,5I8)
   77   FORMAT('******************************************************')
   77   FORMAT('******************************************************')
   78   FORMAT('FFU2')
   78   FORMAT('FFU2')
   79   FORMAT('FFI2')
   79   FORMAT('FFI2')
   99   format(24f25.14)
   99   format(24f25.10)

  191   FORMAT(32I2)
  195   FORMAT(16F10.5)
  196   FORMAT(60E25.10)
  196   FORMAT(120E25.10)
  197   FORMAT(16E25.10)
  197   FORMAT(16E25.10)
  198   FORMAT(16F25.10)
  198   FORMAT(16F25.10)
  199   format(16f25.10)
  199   format(8f25.10)

  215   FORMAT(8F35.10)
  296   FORMAT(16F25.23)
  296   FORMAT(16F25.23)
  298   FORMAT(16F25.10)
  299   FORMAT(64E25.10)

  333   FORMAT(5I3)
  334   FORMAT(15A1)
  335   FORMAT(13A1)
  336   FORMAT(204E9.2)
  337   FORMAT(204(E8.2,1X))

  991   FORMAT('BLOCK 1 RUNS')
  991   FORMAT('BLOCK 1 RUNS')
  992   FORMAT('BLOCK 2 RUNS')
  992   FORMAT('BLOCK 2 RUNS')
  993   FORMAT(I3,I3,I3)
  993   FORMAT(I3,I3,I3)
  995   FORMAT('CALL RASCHET')
  995   FORMAT('CALL RASCHET')
  998   FORMAT(5X, 5I10)
  998   FORMAT(5X, 5I10)
  999   FORMAT(5X, F16.8)
  999   FORMAT(5X, F16.8)


********************* Трейсер переменных на Фортране ****************************

AAH = "Промзона       "
BBH = "ПЗ-Пог1      "

NN1 = 1 = pris_num
N1 = N3 = 560 = num_recs // количество измерении в Excel файле
N2 = 1

K1 = K3 = 50 = num_harms
K2 = 1

pi=3.14159265358979
AL = complex(-0.5, 0.866025)
FF=50

MM = 5 // дина линии (км)
MPR = 3 // количество проводов
MTR = 1 // количество тросов
DT = 2.5 // интервал измерении (мин)
MT = 5 // количество заземлении троса

*** Global variables (should be passed by refence) ***
COMMON MM,M,M1,MT,M10,M20,PR,K1,K2,K3,N1,N2,N3,MPR,MTR,MMT
COMMON MM,M,M1,MT,M10,M20,PR,K1,K2,K3,N1,N2,N3,MPR,MTR,MMT

UM [700][50][3] = Амплитуда Напряжения
FUM [700][50][3] = Фаза Напряжения
AIM [700][50][3] = Амплитуда Тока
FIM [700][50][3] = Фаза Тока
knsu [700][3] = THD Напряжения (Total Harmonic Distortion) (Коэффициент Нелинейных Искажении)
knsi [700][3] = THD Тока (Total Harmonic Distortion) (Коэффициент Нелинейных Искажении)
rmsu [700][3] = RMS Напряжения (Root Mean Square) (Средне квадратическое)
rmsi [700][3] = RMS Тока (Root Mean Square) (Средне квадратическое)
funu [700][3] = Амплитуда Основной Гармоники Напряжения
funi [700][3] = Амплитуда Основной Гармоники Тока
fu [700][3] = Фаза Основной Гармоники Напряжения
fi [700][3] = Фаза Основной Гармоники Тока


***************** Логика программы расчета на Фортран *****************

-> переход 1500
-> переход 1700
    [Блок #1]
        опрос 1111 ->
        опрос 1111 ->
    [Блок #2]
-> переход 1111
    [Блок #3]
        опрос 1700 ->
        опрос 1500 ->

Пояснение:
    1111 -> Если (К > 0) ИЛИ (K == 0 И PR == 2)
    1700 -> Если (K == 0 И PR == 1)
    1500 -> Если (PR == 2)

    1111 Пропускает Блок #2
    1700 НЕ начинает новый цикл, (но выполняет все заново) и делает PR + 1.
    1500 Начинает новый цикл

Каждый новый цикл обнуляет PR, но затем добавляет к нему +1




*********** Вспомогательные кусочки кода на разных языках ************


Chekc Type of Variable = typeid(var).name()
                        OR call_value.typeAsString()


Hint: int marr[10][10] = {}; 2-dim array filled with zeros


complex<float> matrix[3][50][560] = {};
               matrix[фазы][гармоники][кол.измерен] !!! Наоборот


WorkSheet.rows(first, last);
WorkSheet.rows(last);
WorkSheet.rows();

debug_file << value.typeAsString() << " | " << value << endl;



in Sheets 1, 3, 5:
    UM, FUM [49 times]
in Sheets 2, 4, 6:
    AIM, FIM [49 times] ... knsu, knsi, rmsu, rmsi, funu, funi, fu, fi



//for (auto& value : std::deque<XLCellValue>(row.values())) {
    // for every VALUE in ROW...
    //std::debug_file << value.typeAsString() << " | " << value << endl;
}

//double cell_value = wks.cell("a2").value();
//debug_file << cell_value << endl;

//using Eigen::MatrixXcf;

//debug_file << "Row number: " << rows_counter << endl;
//debug_file << "Harmonic number: " << h << " || Amp index: " << amp << " , Pha index: " << pha << " ||" << endl;
//debug_file << "Sheet number: " << sheets_counter << " || Phase number: " << phase_number << endl;
//debug_file << " " << endl;

//debug_file << " *********** Before conversion *********** " << endl;
//debug_file << "Amp cell value: " << cell.at(amp) << " || Type of: " << cell.at(amp).typeAsString() << endl;
//debug_file << "Pha cell value: " << cell.at(pha) << " || Type of: " << cell.at(pha).typeAsString() << endl;
//debug_file << " " << endl;

MatrixXcf my_matrix;
my_matrix = MatrixXcf::Zero(3, 3);
my_matrix(1, 2) = mycomplex;

Matrix <complex<float>, 3, 3 > my_matrix;
my_matrix.setZero();
my_matrix(1, 2) = mycomplex;


for (auto& cell_value : row.cells())
{
    //debug_file << cell_value << endl;
    //std::debug_file << "Worksheet: " << worksheet_name << " || Row: " << cell_value.cellReference().row() << " || Column: " << cell_value.cellReference().column() << " || Value: " << cell_value.value() << endl;
}

//int row_number = row.rowNumber();


[0] = 1
[1] = 562
[2] = 1123
[3] = 1685
[4] = 2246
[5] = 2809
[6] = last row number


1 [0] 1    +1
  [1] 562  -1

2 [1] 562  +1
  [2] 1123 -1

3 [2] 1123 +1
  [3] 1685 -1

4 [3] 1685 +1
  [4] 2246 -1

5 [4] 2246 +1
  [5] 2809 -1

6 [5] 2809 +1
  [ ] rows_count <- append(last_row_number)

debug_file << index << " || " << amp << " , " << pha << " ||" << endl;

insert_gap();
debug_file << "******************** " << worksheet_name << " ********************" << endl;
debug_file << worksheet_name << "'s Columns count: " << w_columns_count << endl;
debug_file << worksheet_name << "'s Rows count: " << w_rows_count << endl;
insert_gap();


debug_file << "Row number: " << rows_counter << endl;
debug_file << "Harmonic number: " << h << " || Amp index: " << amp << " , Pha index: " << pha << " ||" << endl;
debug_file << "Sheet number: " << sheets_counter << " || Phase number: " << phase_number << endl;
debug_file << " " << endl;

debug_file << "Phase number: " << phase_number << " Rows counter: " << rows_counter << " Last column index: " << w_columns_count - 1 << endl;


.get<float>()


sheets_counter = [1, 2, 3, 4, 5, 6]
                 |  0 | | 1 | | 2 |

phase =  0  1  2
sheets = 1, 3, 5
sheets = 2, 4, 6

when even = (sheets_counter-2)/2
when odd = sheet-1, sheet-2, sheet-3, ...



knsu[phase_number][rows_counter] = float(cell.at(w_columns_count-8));
knsi[phase_number][rows_counter] = float(cell.at(w_columns_count-7));
rmsu[phase_number][rows_counter] = float(cell.at(w_columns_count-6));
rmsi[phase_number][rows_counter] = float(cell.at(w_columns_count-5));
funu[phase_number][rows_counter] = float(cell.at(w_columns_count-4));
funi[phase_number][rows_counter] = float(cell.at(w_columns_count-3));
fu[phase_number][rows_counter] = float(cell.at(w_columns_count-2));
fi[phase_number][rows_counter] = float(cell.at(w_columns_count-1));

int phase = 0;
debug_file << knsu[phase][i] << " | " << knsi[phase][i] << " | " << rmsu[phase][i] << " | " << rmsi[phase][i] << " | " << funu[phase][i] << " | " << funi[phase][i] << " | " << fu[phase][i] << " | " << fi[phase][i] << endl;
//debug_file << "Value of row (" << i+2 << "): " << UM[0][1][i] << endl;


// TESTING CREATED MATRICES
int phase = 0;
for (int i = 0; i < 560; i++)
{
    //debug_file << "Value of row (" << i+2 << "): " << UM[0][1][i] << endl;
    debug_file << knsu[phase][i] << " | " << knsi[phase][i] << " | " << rmsu[phase][i] << " | " << rmsi[phase][i] << " | " << funu[phase][i] << " | " << funi[phase][i] << " | " << fu[phase][i] << " | " << fi[phase][i] << endl;

}


for (int i = 0; i < w_columns_count-(num_harms * 2); i++)
{
    try { main_harm[i][phase_number][rows_counter] = cell.at(num_harms*2 + i).get<float>(); }
    catch (XLValueTypeError) { main_harm[i][phase_number][rows_counter] = (float)cell.at(num_harms*2 + i).get<int>(); }
}




// ****************************************************** # DEBUGGING # ******************************************************

// TESTING CREATED MATRICES
int phase = 0;
for (int i = 0; i < 560; i++)
{
    //debug_file << "Value of row (" << i+2 << "): " << UM[0][1][i] << endl;
    debug_file << main_harm[0][phase][i] << " || "
        << main_harm[1][phase][i] << " || "
        << main_harm[2][phase][i] << " || "
        << main_harm[3][phase][i] << " || "
        << main_harm[4][phase][i] << " || "
        << main_harm[5][phase][i] << " || "
        << main_harm[6][phase][i] << " || "
        << main_harm[7][phase][i] << endl;

}

insert_end_separator();

auto degub_stop = high_resolution_clock::now();
auto debug_duration = duration_cast<seconds>(degub_stop - start);
debug_file << "Took to execute: " << debug_duration.count() << " seconds." << std::endl;
std::cout << "Execution has just finished!" << std::endl;

return 0;
// TESTING CREATED MATRICES

// ****************************************************** # DEBUGGING # ******************************************************




int MM = 5; int MPR = 3; int MTR = 1; float DT = 2.5; int MT = 5;


std::complex<float> test = std::complex<float>(10.0, 2.0);
cout << test << endl;
return 0;

C @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ DEBUGGING TOOL @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
C   PRINT *,AIXM(I)
C   WRITE(777,*)AIX(I)
C @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ DEBUGGING TOOL @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@


Keep in mind: K = [1-50], N = [1-560] in FORTRAN

        Matrix[700][50][3] in FORTRAN
        Matrix[3][50][700] in C++


Arrays(variables) that have to be converted into Eigen Matrices


HH11 HH21 HH13 HH23 HH32 HH42 HH34 HH44
F F2 F3 F4 F5 F6 F7 F10
B B1 B4 B6 B7 B10
DET1 DET2 DET10 DET20
GG GG1 GG2 GG4 GG5
LU LU1 LU2 LU3
LI LI1 LI2 LI3
AA BB CC DD
AIK1 UK1
HC1 HC3
EVU EVI
SS SS1
A1 A2
Z Y
AU
AAI


//  Над данными (ниже) переменными (матрицами) будут проведены матричные операции

VectorXcd UK1; UK1 = VectorXcd::Zero(num_phases+num_tross);
VectorXcd AIK1; AIK1 = VectorXcd::Zero(num_phases+num_tross);

MatrixXcd HH11; HH11 = MatrixXcd::Zero(M, M);
MatrixXcd HH21; HH21 = MatrixXcd::Zero(M, M);
MatrixXcd HH13; HH13 = MatrixXcd::Zero(M, M);
MatrixXcd HH23; HH23 = MatrixXcd::Zero(M, M);
MatrixXcd HH32; HH32 = MatrixXcd::Zero(M, M);
MatrixXcd HH42; HH42 = MatrixXcd::Zero(M, M);
MatrixXcd HH34; HH34 = MatrixXcd::Zero(M, M);
MatrixXcd HH44; HH44 = MatrixXcd::Zero(M, M);

VectorXd DET10; VectorXd DET20; VectorXd SS; VectorXd SS1;
VectorXcd DET1; DET1 = VectorXcd::Zero(M);
VectorXd DET2; DET2 = VectorXd::Zero(M);

MatrixXcd GG;  GG = MatrixXcd::Zero(M20, M20);
MatrixXcd GG1; GG1 = MatrixXcd::Zero(M20, M20);
MatrixXcd GG2; GG2 = MatrixXcd::Zero(M20, M20);
MatrixXcd GG4; GG4 = MatrixXcd::Zero(M10, M10);
MatrixXcd GG5; GG5 = MatrixXcd::Zero(M10, M10);

MatrixXcd F; F = MatrixXcd::Zero(M, M);
MatrixXd F2; F2 = MatrixXd::Zero(M, M);
MatrixXd F3; F3 = MatrixXd::Zero(M, M);
MatrixXd F4; F4 = MatrixXd::Zero(M, M);
MatrixXd F5; F5 = MatrixXd::Zero(M, M);
MatrixXd F6; F6 = MatrixXd::Zero(M, M);
MatrixXd F7; F7 = MatrixXd::Zero(M, M);
MatrixXd F10; F10 = MatrixXd::Zero(M, M);

VectorXd B; B = VectorXd::Zero(M);
VectorXcd B1; B1 = VectorXcd::Zero(M20);
VectorXd B4; B4 = VectorXd::Zero(M20);
VectorXd B6; B6 = VectorXd::Zero(M10);
VectorXd B7; B7 = VectorXd::Zero(M10);
VectorXcd B10; B10 = VectorXcd::Zero(M10);

MatrixXcd LU;  LU = MatrixXcd::Zero(M, M);
MatrixXcd LU1; LU1 = MatrixXcd::Zero(M, M);
MatrixXcd LU2; LU2 = MatrixXcd::Zero(M, M);
MatrixXcd LU3; LU3 = MatrixXcd::Zero(M, M);
MatrixXcd LI;  LI = MatrixXcd::Zero(M, M);
MatrixXcd LI1; LI1 = MatrixXcd::Zero(M, M);
MatrixXcd LI2; LI2 = MatrixXcd::Zero(M, M);
MatrixXcd LI3; LI3 = MatrixXcd::Zero(M, M);

MatrixXcd Z; Z = MatrixXcd::Zero(M, M);
MatrixXcd Y; Y = MatrixXcd::Zero(M, M);

VectorXd AA; AA = VectorXd::Zero(M);
VectorXd BB; BB = VectorXd::Zero(M);
MatrixXd CC; CC = MatrixXd::Zero(M, M);
MatrixXd DD; DD = MatrixXd::Zero(M, M);

MatrixXd HC1; HC1 = MatrixXd::Zero(M, M);
MatrixXd HC3; HC3 = MatrixXd::Zero(M, M);

VectorXd EVI; EVI = VectorXd::Zero(M);
VectorXd EVU; EVU = VectorXd::Zero(M);

MatrixXd AU; AU = MatrixXd::Zero(M, M);
MatrixXd AAI; AAI = MatrixXd::Zero(M, M);



**************************** Old Version of Declaring(Defining) Variables(Matrices) ********************************


    std::complex<double> UK1[8] = {0}; std::complex<double> AIK1[8] = {0};


    // Объявление основных (локальных) переменных внутри функции расчета.
    double R0[M] = { 0 }, R[M] = { 0 }, UXM[M] = { 0 }, HI[M] = { 0 }, R11[M] = { 0 }, DET2[M] = { 0 }, DET4[M] = { 0 },
           EVU[M] = { 0 }, EVI[M] = { 0 }, BB[M] = { 0 }, AIXM[M] = { 0 }, AA[M] = { 0 };
    std::complex<double> B[M] = { 0 }, UX[M] = { 0 }, AIX[M] = { 0 }, SM[M] = { 0 }, DET1[M] = { 0 }, DET3[M] = { 0 };

    double B4[M20] = { 0 };
    std::complex<double> B1[M20] = { 0 }, B5[M20] = { 0 };

    double B6[M10] = { 0 }, B7[M10] = { 0 };
    std::complex<double> B10[M10] = { 0 };

    double DET10[]={0}, DET20[] = { 0 }, SS[] = { 0 }, SS1[] = { 0 };

    double HC1[M][M]={0}, HC2[M][M] = { 0 }, HC3[M][M] = { 0 }, HC4[M][M] = { 0 }, F10[M][M] = { 0 },
           XL[M][M] = { 0 }, XL1[M][M] = { 0 }, G[M][M] = { 0 }, D[M][M] = { 0 }, HC[M][M] = { 0 };

    double AU[M][M] = { 0 }, AAI[M][M] = { 0 };
    std::complex<double> Z[M][M] = { 0 }, Y[M][M] = { 0 }, E[M][M] = { 0 }, F[M][M] = { 0 }, F1[M][M] = { 0 };

    double F2[M][M] = { 0 }, D1[M][M] = { 0 }, D2[M][M] = { 0 }, D3[M][M] = { 0 };

    std::complex<double> LU[M][M] = { 0 }, LU1[M][M] = { 0 }, LU2[M][M] = { 0 }, LU3[M][M] = { 0 };
    std::complex<double> LI[M][M] = { 0 }, LI1[M][M] = { 0 }, LI2[M][M] = { 0 }, LI3[M][M] = { 0 };

    double F3[M][M] = { 0 }, F4[M][M] = { 0 }, F5[M][M] = { 0 }, F6[M][M] = { 0 }, F7[M][M] = { 0 };

    double HH[M10][M10] = { 0 };
    std::complex<double> HH11[M][M] = { 0 }, HH12[M][M] = { 0 }, HH13[M][M] = { 0 }, HH14[M][M] = { 0 },
                         HH21[M][M] = { 0 }, HH22[M][M] = { 0 }, HH23[M][M] = { 0 }, HH24[M][M] = { 0 },
                         HH31[M][M] = { 0 }, HH32[M][M] = { 0 }, HH33[M][M] = { 0 }, HH34[M][M] = { 0 },
                         HH41[M][M] = { 0 }, HH42[M][M] = { 0 }, HH43[M][M] = { 0 }, HH44[M][M] = { 0 };

    double CC[M][M] = { 0 }, DD[M][M] = { 0 };

    std::complex<double>  GG[M20][M20] = { 0 }, GG1[M20][M20] = { 0 }, GG2[M20][M20] = { 0 }, GG3[M10][M20] = { 0 }, GG4[M10][M10] = { 0 }, GG5[M10][M10] = { 0 };


    // Решение проблемы динамических размеров матрицы с помощью библиотеки Eigen
    MatrixXcd A1; A1 = MatrixXcd::Zero(M1, M1);
    MatrixXcd A2; A2 = MatrixXcd::Zero(M1, M1);
    VectorXd IPVT1; IPVT1 = VectorXd::Zero(M1);

    // Решение проблемы с матрицей AG. 3-x мерная [M1][M][M]. М1 - динамичен!!!
    // Создание вектра с размером М1, хранящий в себе все субматрицы с размером МхМ
    std::vector<MatrixXd> AG;
    for (int i = 0; i < M1; i++)
    {
        MatrixXd ag; ag = MatrixXd::Zero(M, M);
        AG.push_back(ag);
    }


VectorXcd UK1; UK1 = VectorXcd::Zero(num_phases + num_tross);
VectorXcd AIK1; AIK1 = VectorXcd::Zero(num_phases+num_tross);

 Code for finding LU factorasiation and determinant

//PartialPivLU<MatrixXcd> part_piv_lu(TestA1);
//MatrixXcd lu_A1 = part_piv_lu.matrixLU();
//dcomplex det_A1lu = lu_A1.determinant();











                    UK10=(UK1(1)+UK1(2)+UK1(3))/3.
                    UK11=(UK1(1)+UK1(2)*AL+UK1(3)*AL**2)/3.
                    UK12=(UK1(1)+UK1(2)*AL**2+UK1(3)*AL)/3.

                    SKU2=SQRT(REAL(UK12)**2+AIMAG(UK12)**2)/SQRT(REAL(UK11)**2+AIMAG(UK11)**2)*100
                    SKU0=SQRT(REAL(UK10)**2+AIMAG(UK10)**2)/SQRT(REAL(UK11)**2+AIMAG(UK11)**2)*100

                    UK1(1)=UK11
                    UK1(2)=UK11*AL**2
                    UK1(3)=UK11*AL

                    AIK10=(AIK1(1)+AIK1(2)+AIK1(3))/3.
                    AIK11=(AIK1(1)+AIK1(2)*AL+AIK1(3)*AL**2)/3.
                    AIK12=(AIK1(1)+AIK1(2)*AL**2+AIK1(3)*AL)/3.

                    SKI2=SQRT(REAL(AIK12)**2+AIMAG(AIK12)**2)/SQRT(REAL(AIK11)**2+AIMAG(AIK11)**2)*100
                    SKI0=SQRT(REAL(AIK10)**2+AIMAG(AIK10)**2)/SQRT(REAL(AIK11)**2+AIMAG(AIK11)**2)*100

                    AIK1(1)=AIK11
                    AIK1(2)=AIK11*AL**2
                    AIK1(3)=AIK11*AL





// ******************************* # DEBUGGER BLOCK # *******************************
//std::cout << "Writing to debug file..." << endl;

// Loop's values printing module
debug_file << "|| Loop # || k: " << k << " || n: " << n << " || PR: " << PR << endl;

// Matrix(es) checking module
//for (int i = 0; i < 560; i++){
//  for (int k = 0; k < 50; k++){
//    auto value2check = AIM1[0][k][i];
//    if (value2check < 0) debug_file << scientific << value2check << "   ";
//    else debug_file << scientific << " " << value2check << "   ";}
//  debug_file << endl;}
//std::cout << "Writing to debug file has been finished!" << endl;
//return 0;

// Other cases checker module
//debug_file << scientific << UM1[0][k][n] << "   " << UM2[0][k][n]  << endl;
debug_file << "UK1(0) after definging: " << endl;
debug_file << scientific << UK1(0)  << endl;

//insert_gap();
// ******************************* # DEBUGGER BLOCK # *******************************



// ******************************* # DEBUGGER BLOCK # *******************************
debug_file << "|| Loop # || k: " << k << " || n: " << n << " || PR: " << PR << endl;
debug_file << scientific << "UK1(0): " << UK1(0) << " || UK1(1): " << UK1(1) << " || UK1(2): " << UK1(2) << endl;
insert_gap();
// ******************************* # DEBUGGER BLOCK # *******************************




C @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ DEBUGGING TOOL @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
C      PRINT *,AIXM(I)
C DO 789 I=1,560
  WRITE(777,*) K,N,PR
C WRITE(777,337)(UK1(I,K,1),K=1,50)
C      WRITE(777,337) UM1(N,K,1),UM2(N,K,1)
      WRITE(777,337) UK1(3)
  WRITE(777,*) '       '
C789  CONTINUE
C @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ DEBUGGING TOOL @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@




G20 = 16 ||| G10 = 8

MatrixXcd GG;  GG = MatrixXcd::Zero(M20, M20);
MatrixXcd GG1; GG1 = MatrixXcd::Zero(M20, M20);
MatrixXcd GG2; GG2 = MatrixXcd::Zero(M20, M20);
MatrixXcd GG3; GG3 = MatrixXcd::Zero(M10, M20);
MatrixXcd GG4; GG4 = MatrixXcd::Zero(M10, M10);
MatrixXcd GG5; GG5 = MatrixXcd::Zero(M10, M10);






IN RASCHET SUBROUTINE (FUNCTION) VARIABLES CHECKER


HC1 - fine!
HC3 - fine!
F10 - NOT FINE!!! even though F10 is the product of HC1 and HC3
